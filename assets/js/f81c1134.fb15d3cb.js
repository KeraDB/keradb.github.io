"use strict";(globalThis.webpackChunkkeradb_docs=globalThis.webpackChunkkeradb_docs||[]).push([[130],{7735:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"keradb-vs-sqlite-benchmark-v0-1-0","metadata":{"permalink":"/blog/keradb-vs-sqlite-benchmark-v0-1-0","source":"@site/blog/2025-11-30-keradb-benchmark.md","title":"KeraDB vs SQLite Benchmark (v0.1.0)","description":"This post summarizes the results of our v0.1.0 benchmark comparison between KeraDB, an embedded NoSQL + vector search database, and SQLite, the widely used embedded relational engine.","date":"2025-12-01T00:00:00.000Z","tags":[{"inline":true,"label":"benchmark","permalink":"/blog/tags/benchmark"},{"inline":true,"label":"performance","permalink":"/blog/tags/performance"},{"inline":true,"label":"sqlite","permalink":"/blog/tags/sqlite"},{"inline":true,"label":"nosql","permalink":"/blog/tags/nosql"},{"inline":true,"label":"vector-search","permalink":"/blog/tags/vector-search"}],"readingTime":2.58,"hasTruncateMarker":true,"authors":[{"name":"KeraDB Team","title":"Core Team","url":"https://github.com/keradb","imageURL":"https://github.com/keradb.png","key":"keradb","page":null}],"frontMatter":{"slug":"keradb-vs-sqlite-benchmark-v0-1-0","title":"KeraDB vs SQLite Benchmark (v0.1.0)","authors":["keradb"],"tags":["benchmark","performance","sqlite","nosql","vector-search"],"date":"2025-12-01T00:00:00.000Z"},"unlisted":false,"nextItem":{"title":"Introducing KeraDB","permalink":"/blog/introducing-keradb"}},"content":"This post summarizes the results of our **v0.1.0 benchmark comparison** between **KeraDB**, an embedded NoSQL + vector search database, and **SQLite**, the widely used embedded relational engine.  \\nThe goal is to highlight the strengths of each system and provide transparency on where KeraDB excels today\u2014and where we plan to optimize next.\\n\\n\x3c!-- truncate --\x3e\\n\\nAll results are taken from our Criterion.rs benchmark suite.\\n\\n---\\n\\n## Quick Comparison\\n\\n| Category | Winner | Notes |\\n|---------|--------|-------|\\n| Single Insert | **KeraDB (~240\xd7 faster)** | No SQL parsing; native document write path |\\n| Point Query | **KeraDB (~5\xd7 faster)** | Hash-based lookup; no query parser |\\n| Complex JSON Insert | **KeraDB (~124\xd7 faster)** | Efficient binary document storage |\\n| Mixed Read/Write (80/20) | **KeraDB (~63\xd7 faster)** | Optimized for interactive workloads |\\n| Delete (100 docs) | **KeraDB (2\xd7 faster)** | Low overhead for small batches |\\n| Bulk Inserts (5,000 docs) | **SQLite (~4\xd7 faster)** | Transaction batching efficiency |\\n| Range Queries | **SQLite (7\u201339\xd7 faster)** | Optimized B-tree sequential scanning |\\n| Storage Throughput | **SQLite (~10\xd7 faster)** | WAL + batched disk sync advantages |\\n\\n---\\n\\n## Key Metrics\\n\\n### Single Document Insert\\n| Database | Mean Time |\\n|----------|-----------|\\n| **KeraDB** | **33.7 \xb5s** |\\n| SQLite | 8.19 ms |\\n\\n### Complex JSON Insert\\n| Database | Mean Time |\\n|----------|-----------|\\n| **KeraDB** | **35.6 \xb5s** |\\n| SQLite | 4.40 ms |\\n\\n### Point Query (Lookup by ID)\\n| Database | Mean Time |\\n|----------|-----------|\\n| **KeraDB** | **22.9 \xb5s** |\\n| SQLite | 115 \xb5s |\\n\\n### Mixed Read/Write (80/20 Workload)\\n| Database | Mean Time per Op |\\n|----------|------------------|\\n| **KeraDB** | **14.5 \xb5s** |\\n| SQLite | 916 \xb5s |\\n\\n### Range Queries\\n| Limit | KeraDB | SQLite |\\n|-------|--------|--------|\\n| 10 docs | 834 \xb5s | 111 \xb5s |\\n| 100 docs | 3.53 ms | 164 \xb5s |\\n| 1000 docs | 27.6 ms | 714 \xb5s |\\n\\n### Bulk Insert (5,000 docs)\\n| Database | Time |\\n|----------|------|\\n| KeraDB | 153 ms |\\n| **SQLite (Transaction)** | **37 ms** |\\n\\n### Storage Throughput (5,000 docs + sync)\\n| Database | Throughput |\\n|----------|------------|\\n| KeraDB | 25.8K docs/sec |\\n| **SQLite** | **255K docs/sec** |\\n\\n---\\n\\n## Interpretation\\n\\n### Where KeraDB Excels\\nKeraDB consistently dominates in **low-latency, document-centric** operations:\\n\\n- Very fast single inserts and point queries  \\n- High performance for nested/complex JSON  \\n- Excellent under mixed read/write workloads  \\n- Strong small-batch deletion performance  \\n- Zero configuration and native document formats  \\n\\nThese characteristics make KeraDB ideal for:\\n\\n- Local-first applications  \\n- Edge/agent workflows  \\n- AI pipelines and LLM tooling  \\n- Apps working heavily with JSON documents  \\n- Workloads needing predictable sub-100\xb5s response times  \\n\\n---\\n\\n### Where SQLite Excels\\nSQLite remains exceptional for **relational batch operations** and **large sequential scans**:\\n\\n- Bulk inserts scale extremely well with transactions  \\n- Range queries are significantly faster  \\n- Write-ahead logging provides strong bulk throughput  \\n- SQL-based analytics remain unmatched  \\n\\nSQLite is still the better fit for:\\n\\n- Analytical queries  \\n- High-volume batch ingestion  \\n- Heavy use of `LIMIT/OFFSET` style iteration  \\n- Relational schemas and SQL flexibility  \\n\\n---\\n\\n## What\u2019s Next for KeraDB\\n\\nBased on the benchmark profile, our upcoming optimization areas include:\\n\\n- Improving range scan performance  \\n- Adding cursor-based iteration  \\n- Exploring lazy/lite document deserialization  \\n- Optional batched write mode  \\n- Reduced overhead for large result sets  \\n\\nThese improvements will be part of our upcoming releases.\\n\\n---\\n\\n## Final Thoughts\\n\\nKeraDB and SQLite serve different workloads well:\\n\\n- If your application is **document-first**, **JSON-heavy**, or **latency-critical** \u2192 KeraDB is shaping up to be a strong choice.  \\n- If you need **SQL**, **batch-heavy writes**, or **analytical scans** \u2192 use SQLite for now.\\n\\nWe\u2019ll continue publishing benchmark updates as KeraDB evolves.\\n\\nIf you have ideas, feedback, or would like to contribute, feel free to open a discussion or issue in our GitHub repo."},{"id":"introducing-keradb","metadata":{"permalink":"/blog/introducing-keradb","source":"@site/blog/2025-11-30-introducing-keradb.md","title":"Introducing KeraDB","description":"We\'re thrilled to announce the official launch of KeraDB \u2014 a lightweight, embedded database with MongoDB-compatible APIs and built-in vector search capabilities.","date":"2025-11-30T00:00:00.000Z","tags":[{"inline":true,"label":"announcement","permalink":"/blog/tags/announcement"},{"inline":true,"label":"release","permalink":"/blog/tags/release"},{"inline":true,"label":"database","permalink":"/blog/tags/database"},{"inline":true,"label":"vector-search","permalink":"/blog/tags/vector-search"}],"readingTime":1.36,"hasTruncateMarker":true,"authors":[{"name":"KeraDB Team","title":"Core Team","url":"https://github.com/keradb","imageURL":"https://github.com/keradb.png","key":"keradb","page":null}],"frontMatter":{"slug":"introducing-keradb","title":"Introducing KeraDB","authors":["keradb"],"tags":["announcement","release","database","vector-search"]},"unlisted":false,"prevItem":{"title":"KeraDB vs SQLite Benchmark (v0.1.0)","permalink":"/blog/keradb-vs-sqlite-benchmark-v0-1-0"}},"content":"We\'re thrilled to announce the official launch of **KeraDB** \u2014 a lightweight, embedded database with MongoDB-compatible APIs and built-in vector search capabilities.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Why KeraDB?\\n\\nBuilding modern applications often requires a database, but not every project needs the complexity of running a separate database server. Whether you\'re prototyping a new idea, building an Electron app, or developing an AI application that needs vector similarity search, KeraDB provides a simple, powerful solution.\\n\\n### Key Features\\n\\n- **MongoDB-Compatible SDK** \u2014 If you know MongoDB, you already know KeraDB. Our familiar query syntax means zero learning curve.\\n\\n- **Embedded & Serverless** \u2014 No separate database process to manage. Your database lives right alongside your application.\\n\\n- **Vector Search Built-in** \u2014 Perfect for AI/ML applications. Store and query embeddings with efficient similarity search.\\n\\n- **Multi-Language Support** \u2014 Available for Node.js, Python, and Rust with consistent APIs across all platforms.\\n\\n- **Lightweight & Fast** \u2014 Written in Rust for maximum performance with minimal footprint.\\n\\n## Getting Started\\n\\nGetting up and running takes just a few lines of code:\\n\\n```javascript\\nconst { KeraDB } = require(\'keradb\');\\n\\nconst db = new KeraDB(\'./myapp.db\');\\nconst users = db.collection(\'users\');\\n\\nawait users.insertOne({ \\n  name: \'Alice\', \\n  email: \'alice@example.com\' \\n});\\n\\nconst user = await users.findOne({ name: \'Alice\' });\\n```\\n\\n## What\'s Next?\\n\\nThis is just the beginning. We\'re actively working on:\\n\\n- Enhanced vector search algorithms\\n- Additional language SDKs\\n- Performance optimizations\\n- More query operators\\n\\n## Join the Community\\n\\nWe\'d love to hear from you! Check out our [documentation](/docs) to get started, and don\'t hesitate to:\\n\\n- Star us on [GitHub](https://github.com/keradb/keradb)\\n- Report issues or request features\\n- Join the conversation\\n\\nThank you for being part of the KeraDB journey. We can\'t wait to see what you build!\\n\\n*\u2014 The KeraDB Team*"}]}}')}}]);